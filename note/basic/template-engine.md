# テンプレートエンジン
- サーバサイドインクルードから進化したもの
- 上記の後に、PHP、ColdFusion、ASPなどのテンプレートエンジンなどのプログラミング言語に組み込まれ、枝分かれした。
- そのため、それぞれが作成された理由に応じて、その機能は様々に異なっている。

※PHPは、元はテンプレートエンジンとして作られたが、その後、プログラミング言語として発展した。

## 2種類のテンプレートエンジン
- ロジックなしのテンプレートエンジン
    - 動的なデータでテンプレート内に指定されたプレースホルダを置換する。
    - ロジックの処理はまったく行わず、文字列の置換のみを行う。
    - 表現とロジックを分離するのが元にある考え
    - ロジックはハンドラによって行われる。
- ロジック埋め込みテンプレートエンジン
    - プログラミング言語のコードをテンプレートに埋め込み、実行時にテンプレートエンジンなどによって、置換などの処理を行う。
    - とても強力な反面、ロジックがテンプレートとハンドラに分散しがちでコードの保守性が低下することもある。

## それぞれの問題点
- ロジック埋め込み型
    - 表現の内容とロジックが混在し、ロジックが複数個所に分散して、コードの保守性が悪くなる
- ロジックなし型
    - テンプレート内にロジックを書くことができないため、テンプレート内での処理ができない。
    - 実用性に欠ける
    - 表示に関するロジックをハンドラに書く必要があるため、ハンドラが複雑化する。

## Goのテンプレートエンジン
- 上記の2つの中間的な位置づけ
- アクションが埋め込まれている
    - アクション：テンプレート内で実行されるGoのコード
    - `{{...}}`で囲まれた部分がアクション
    - `.`：現在のコンテキストを表す
- アクションの含まれたテンプレートをパースして、新たなテキストを生成する。
- 種類（標準ライブラリに組み込まれているモノ）
    - text/template：任意のテキスト形式用の汎用テンプレートエンジン
    - html/template：HTML専用のテンプレートエンジン
- 拡張子は任意。

## テンプレートを使用する手順
1. テキスト形式のテンプレートソースを解析し、テンプレート構造体を生成する
1. ResponseWriterと何らかのデータを引数として、解析済みのテンプレートを実行する（Execute(👈メソッド)）。これにより、テンプレートエンジンが解析済みテンプレートにデータを組み込んで、ResponseWriterに渡す最終的なHTMLを生成する。

## `template.ParseFiles(<テンプレートファイル名>)`
- テンプレートファイルを解析する関数
- 戻り値
    - テンプレート構造体
    - エラー
- 引数
    - テンプレートファイル名
        - 複数指定可能
        - ファイル名は、絶対パスでも相対パスでもOK

## `template.ParseGlob(<テンプレートファイル名>)`
- テンプレートファイルを解析する関数
- 戻り値
    - テンプレート構造体
    - エラー
- 引数
    - テンプレートファイル名
        - ワイルドカードを使用可能
        - `template.ParseGlob("templates/*.html")`

## `template.Must(<テンプレート構造体>, <エラー>)`
- テンプレート構造体とエラーを受け取り、エラーがnilでない場合は、panicを発生させる関数
- 戻り値
    - テンプレート構造体
- 引数
    - テンプレート構造体
    - エラー

## template.Execute()
- 値をテンプレートに埋め込んで、結果をResponseWriterに書き込む関数
- 戻り値
    - エラー
- 引数
    - ResponseWriter
    - テンプレート構造体
    - テンプレートに埋め込む値

## `<templateの変数名>.Execute()`
- 値をテンプレートに埋め込んで、結果をResponseWriterに書き込むメソッド
- 戻り値
    - エラー
- 引数
    - ResponseWriter
    - テンプレートに埋め込む値

## サンプルコード
```go
package main

import (
    "html/template"
    "net/http"
)

func process(w http.ResponseWriter, r *http.Request) {
    t, _ := template.ParseFiles("tmpl.html")
    t.Execute(w, "Hello World!")
}

func main() {
    server := http.Server{
        Addr: "127.0.0.0:8080",
    }
    http.HandleFunc("/process", process)
    server.ListenAndServe()
}
```

## アクション
- データをテンプレートに結合する方法に関する指示。
- Goのテンプレートに埋め込むコマンド
- `{{...}}`で囲まれた部分がアクション
- 代表的なアクション
    - 条件アクション
        - `{{if <条件>}}`
        - `{{else}}`
        - `{{end}}`
    - イテレータアクション
        - `{{range <配列>}}`
        - `{{end}}`
        - ```go
            {{range .}}
                {{.}}
            {{end}}
            ```
    - 代入アクション
        - コンテキストに代入するアクション
        - スコープの範囲のみで有効（一時的に代入するイメージ）
        - `{{with <変数>}}`
        - `{{else}}`：`{{with}}`の条件がfalseの場合に実行される
        - `{{end}}`
        - ```go
            {{with arg}}
                ドットにargの値が代入されている
            {{else}}
                ドットにargの値が代入されていない
            {{end}}
            ```
    - インクルードアクション
        - 別のテンプレートをインクルードするアクション
        - `{{template "<テンプレート名> [<引数>]"}}`
    - パイプラインアクション
        - パイプラインを使用して、関数を呼び出すアクション
        - `{{<関数名> [<引数>...]}}`
        - `{{<関数名> [<引数>...] | <関数名> [<引数>...]}}`
        - `{{<関数名> [<引数>...] | <関数名> [<引数>...] | <関数名> [<引数>...]}}`
    - ブロックアクション
        - ブロックを定義するアクション
        - `{{block "<ブロック名>" [<引数>...]}}`
        - `{{end}}`
- `.`もアクションの一種。コンテキスト。テンプレートに渡されたデータをその値とするアクション。
- `{{ define "<テンプレート名>" }}`と`{{ end }}`で囲まれた部分は、テンプレートとして定義される（ブロックアクションは後発）。

## テンプレートで使われる用語の整理
- 引数：テンプレートに渡されるデータ
- ドット：テンプレートに渡されたデータ
- 変数：テンプレート内で定義された変数
- パイプライン：`|`で区切られた関数の呼び出し

## テンプレートエンジンで使える関数
- 基本的な組み込み関数は一式用意されている
- 加えて、プログラマが独自に関数を定義することも可能
- テンプレートで使える関数に制限がある
    - 引数は任意の個数
    - 戻り値は1つ（2つ目の戻り値がエラーの場合は除く）

## カスタム関数を定義する方法
1. 関数の名前をキーとして実際の関数を値とするマップFuncMapを作成する
1. そのFuncMapをテンプレートに付与する

## カスタム関数の例（ＩＳＯ8601形式の日付を適切な文字列に変換する関数）

```go
package main

import (
    "html/template"
    "net/http"
    "time"
)

func formatDate(t time.Time) string {
    layout := "2006-01-02"
    return t.Format(layout)
}

func process(w http.ResponseWriter, r *http.Request) {
    funcMap := template.FuncMap{"fdate": formatDate}
    t := template.New("tmpl.html").Funcs(funcMap)
    t, _ = t.ParseFiles("tmpl.html")
    t.Execute(w, time.Now())
}

func main() {
    server := http.Server{
        Addr: "127.0.0.0:8080",
    }
    http.HandleFunc("/process", process)
    server.ListenAndServe()
}
```


    
## コンテキスト依存処理
- Goのテンプレートエンジンでは、表示するコンテンツはコンテキストに応じて変わる。
- 表示されるコンテンツが、ドキュメント内のどこにそれを配置したかによって変わる。
- 自動的な防御的プログラミング。
- わかりやすい使われ方
    - 表示コンテンツに適切なエスケープ処理を行う
    - わかりやすい表
    |コンテキスト|コンテンツ（テキスト）|
    |---|---|
    | 元のテキスト | `I asked: <i> "What's up?"</i>` |
    | {{.}} | `I asked: &lt;i&gt;&34;What&#39;s up?&#34;&lt;/i&gt;` |
    | <a href="/?q={{.}}"> | `<a href="/?q=I+asked%3A+%3Ci%3E+%22What%27s+up%3F%22%3C%2Fi%3E">` |
    | <a onClick="alert('{{.}}');"> | `<a onClick="alert('I asked: \x3ci\x3e \x22What\x27s up?\x22\x3c/i\x3e');">` |


## HTMLのエスケープ処理の抑制
- テンプレート内でHTMLのエスケープ処理を抑制する方法
    - `{{.}}`の代わりに`{{{.}}}`を使用する
    - `{{.}}`の代わりに`{{html .}}`を使用する
    - `{{.}}`の代わりに`{{. | html}}`を使用する
- `{{.}}`の代わりに`{{. | html}}`を使用するのがベストプラクティス
- バックエンドでの場合は、`template.HTML`型でキャストする。